---
description: MCP全局代码质量与可维护性指导规范
version: 1.0.0
globs: "**/*"
alwaysApply: true
---

# 🎯 MCP全局代码质量与可维护性指导规范

## 📋 核心原则

### 代码质量原则
- **可读性优先**: 代码应该像文档一样易于理解
- **一致性**: 遵循统一的编码风格和命名约定
- **简洁性**: 避免过度设计，保持代码简洁明了
- **可测试性**: 编写易于测试的代码结构
- **可维护性**: 考虑未来的扩展和修改需求

### 飞书设计规范
- **设计系统一致性**: 严格遵循飞书设计语言
- **用户体验**: 优先考虑用户交互体验
- **无障碍访问**: 遵循WCAG 2.1标准
- **响应式设计**: 支持多种设备和屏幕尺寸

## 🏗️ 架构设计规范

### 组件设计
- **单一职责**: 每个组件只负责一个明确的功能
- **组合优于继承**: 优先使用组合模式
- **Props设计**: 提供清晰的API接口和合理的默认值
- **状态管理**: 合理划分本地状态和全局状态

### 文件组织
- **目录结构**: 按功能模块组织，保持层次清晰
- **命名约定**: 使用语义化的文件和目录名
- **导入导出**: 统一的模块导入导出规范
- **依赖管理**: 避免循环依赖，明确依赖关系

## 💻 编码规范

### JavaScript/React规范
- **ES6+语法**: 优先使用现代JavaScript特性
- **函数式编程**: 优先使用纯函数和不可变数据
- **Hook使用**: 合理使用React Hooks，避免过度优化
- **错误处理**: 完善的错误边界和异常处理

### 样式规范
- **CSS变量**: 使用CSS自定义属性定义设计令牌
- **BEM命名**: 遵循BEM命名约定或类似的系统化方法
- **响应式**: 移动优先的响应式设计
- **性能优化**: 避免不必要的重绘和回流

### 类型安全
- **PropTypes**: 为React组件定义明确的属性类型
- **参数验证**: 对函数参数进行类型检查
- **返回值**: 明确函数返回值类型
- **TypeScript准备**: 代码结构支持未来TypeScript迁移

## 🎨 UI/UX规范

### 飞书设计系统
- **色彩系统**: 使用飞书标准色彩变量
  - 主色: --feishu-primary (#1664FF)
  - 成功: --feishu-success (#00BC70)
  - 警告: --feishu-warning (#FF7D00)
  - 危险: --feishu-danger (#F53F3F)
- **字体系统**: 使用Inter字体族
- **间距系统**: 遵循8px网格系统
- **圆角系统**: 统一的圆角规范(4px, 6px, 8px)

### 组件规范
- **尺寸规范**: 提供mini、small、default、large四种尺寸
- **状态设计**: 明确的hover、focus、active、disabled状态
- **加载状态**: 统一的loading和skeleton设计
- **反馈机制**: 清晰的成功、错误、警告反馈

### 交互规范
- **动画效果**: 使用CSS transition，时长200-300ms
- **键盘导航**: 支持完整的键盘操作
- **触摸友好**: 适配移动端触摸操作
- **性能优化**: 避免阻塞主线程的操作

## 🧪 测试规范

### 测试策略
- **单元测试**: 覆盖核心业务逻辑
- **组件测试**: 测试组件的渲染和交互
- **集成测试**: 测试组件间的协作
- **视觉回归**: 使用截图对比检测UI变化

### 测试工具
- **测试框架**: Vitest + React Testing Library
- **覆盖率**: 保持80%以上的代码覆盖率
- **Mock策略**: 合理使用mock，避免过度mock
- **测试数据**: 使用真实但脱敏的测试数据

## 📚 文档规范

### 代码文档
- **JSDoc注释**: 为公共API提供完整的文档注释
- **README**: 每个模块提供清晰的使用说明
- **CHANGELOG**: 记录版本变更和重要更新
- **示例代码**: 提供实际可运行的示例

### 组件文档
- **API文档**: 详细的Props、Events、Methods说明
- **使用示例**: 多种使用场景的代码示例
- **设计指南**: 何时使用该组件的指导
- **最佳实践**: 常见问题和解决方案

## 🚀 性能规范

### 渲染性能
- **React.memo**: 合理使用memo避免不必要的重渲染
- **useMemo/useCallback**: 优化昂贵的计算和函数创建
- **懒加载**: 对大型组件使用React.lazy
- **虚拟化**: 长列表使用虚拟滚动

### 资源优化
- **代码分割**: 按路由和功能进行代码分割
- **Tree Shaking**: 支持按需导入
- **图片优化**: 使用WebP格式，提供多种尺寸
- **缓存策略**: 合理的浏览器缓存配置

## 🔒 安全规范

### 数据安全
- **输入验证**: 对所有用户输入进行验证和清理
- **XSS防护**: 避免直接插入HTML内容
- **敏感信息**: 不在前端存储敏感数据
- **HTTPS**: 所有网络请求使用HTTPS

### 依赖安全
- **依赖审计**: 定期检查依赖包的安全漏洞
- **版本锁定**: 使用package-lock.json锁定依赖版本
- **最小权限**: 只引入必要的依赖包
- **定期更新**: 及时更新有安全修复的依赖

## 🛠️ 开发工具规范

### 代码质量工具
- **ESLint**: 使用严格的代码检查规则
- **Prettier**: 统一的代码格式化
- **Husky**: Git hooks自动化检查
- **lint-staged**: 提交前代码检查

### 构建工具
- **Vite**: 现代化的构建工具
- **PostCSS**: CSS后处理器
- **Bundle Analyzer**: 分析打包体积
- **Source Maps**: 生产环境的调试支持

## 📦 发布规范

### 版本管理
- **语义化版本**: 遵循SemVer规范
- **变更日志**: 详细记录每个版本的变更
- **向下兼容**: 避免破坏性变更
- **废弃警告**: 提前通知API废弃

### 发布流程
- **自动化发布**: 使用CI/CD自动发布
- **多环境测试**: 在多个环境中验证
- **回滚机制**: 支持快速回滚到上一版本
- **监控告警**: 发布后的性能和错误监控

## 🔄 持续改进

### 代码审查
- **Pull Request**: 所有代码变更通过PR审查
- **审查清单**: 使用标准化的审查清单
- **知识分享**: 通过审查促进团队学习
- **自动化检查**: 结合自动化工具减少人工审查负担

### 重构策略
- **技术债务**: 定期识别和清理技术债务
- **性能优化**: 基于实际数据进行性能优化
- **架构演进**: 渐进式的架构改进
- **工具升级**: 及时采用新的开发工具和最佳实践

---

## 🎯 实施指南

### 新项目
1. 使用本规范作为项目初始化模板
2. 配置相应的开发工具和CI/CD流程
3. 建立团队代码审查流程
4. 定期回顾和更新规范

### 现有项目
1. 逐步引入规范中的最佳实践
2. 优先处理安全和性能相关问题
3. 通过重构逐步提升代码质量
4. 建立度量指标跟踪改进效果

### 团队协作
1. 定期举行代码质量分享会
2. 建立最佳实践知识库
3. 鼓励团队成员贡献改进建议
4. 持续学习和采用新技术

---

**注意**: 本规范是活文档，应根据项目实际情况和技术发展持续更新和完善。